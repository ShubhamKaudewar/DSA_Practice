from typing import List
import pytest
from functools import lru_cache


class Solution:
    def findMaxForm(self, strs: List[str], m: int, n: int) -> int:
        """
        This is classical question of DP knapsack
        DP (knapsack) or DFS + memoization reduces it to polynomial time and passes.
        Approach
            Memoization: Cache the results of the dfs function based on the remaining counts of m (zeros) and n (ones), and the current index in the list. This avoids recalculating the same subproblems repeatedly.
            Iterate through the list: Instead of slicing the list in each recursive call (which is inefficient), pass the current index and iterate from that index onward.
        """
        counts = [(s.count("0"), s.count("1")) for s in strs]

        @lru_cache(None)
        def dfs(i, m, n):
            if i == len(strs):
                return 0
            zeros, ones = counts[i]
            # skip
            res = dfs(i + 1, m, n)
            # take if possible
            if m >= zeros and n >= ones:
                res = max(res, 1 + dfs(i + 1, m - zeros, n - ones))
            return res

        return dfs(0, m, n)


    def findMaxForm1(self, strs: List[str], m: int, n: int) -> int:
        """
        The Time Limit Exceeded (TLE) error in your solution is due to the exponential time complexity of the recursive depth-first search (DFS) approach.
        """
        sorted_lst = sorted(strs, key=len)

        def dfs(s, m, n, lvl, lst):
            ones = s.count("1")
            zeros = len(s) - ones
            m -= zeros
            n -= ones

            if m < 0 or n < 0:
                return 0

            if m == 0 and n == 0:
                return lvl

            ans = lvl
            for i in range(len(lst)):
                r = dfs(lst[i], m, n, lvl+1, lst[i+1:])
                ans = max(ans, r)
            return ans

        res = dfs("", m, n, 0, sorted_lst)
        return res


# def test_case_1():
#     sol = Solution()
#     strs = ["10","0001","111001","1","0"]
#     m = 5
#     n = 3
#     actual = sol.findMaxForm(strs, m, n)
#     expected = 4
#     assert actual == expected
#
# def test_case_2():
#     sol = Solution()
#     strs = ["10","0","1"]
#     m = 1
#     n = 1
#     actual = sol.findMaxForm(strs, m, n)
#     expected = 2
#     assert actual == expected
#
def test_case_3():
    sol = Solution()
    strs = ["1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101"]
    m = 100
    n = 100
    actual = sol.findMaxForm(strs, m, n)
    expected = 50
    assert actual == expected

def test_case_4():
    sol = Solution()
    strs = ["00","000"]
    m = 1
    n = 10
    actual = sol.findMaxForm(strs, m, n)
    expected = 0
    assert actual == expected

def test_case_5():
    sol = Solution()
    strs = ["0","0","1","1"]
    m = 2
    n = 2
    actual = sol.findMaxForm(strs, m, n)
    expected = 4
    assert actual == expected

def test_case_6():
    sol = Solution()
    strs = ["10001110","11000","111110"]
    m = 6
    n = 6
    actual = sol.findMaxForm(strs, m, n)
    expected = 1
    assert actual == expected


if __name__ == '__main__':
    pytest.main()